<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
    <title>Tower Defence with the phaser framework</title>
	<script type="text/javascript" src="js/lib/phaser.js"></script>
	

    
    <style type="text/css">

        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(640, 800, Phaser.CANVAS, '',  {preload: preload, create: create,update: update,render: render});
var goingTo=[];
var player;
var reachedDestination=false;
var q=0;
var layer;
var layer2;
var start;
var finish;
var circle;
var towers;
var bullets;
var enemies;
var life=50;
var self;
var map;
var choiceMenu
function preload(){
  
  game.scale.setShowAll();
  game.scale.setScreenSize();
  game.load.tilemap('map', 'assets/maps/map1.json', null, Phaser.Tilemap.TILED_JSON);
  game.load.image('spritesheet','assets/spritesheet.png');
  game.load.image('tower1','assets/tower1.png');
  game.load.image('tower2','assets/tower2.png');
  game.load.image('bullet','assets/bullet.png');
  game.load.image('menu','assets/menu.png');
  game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
  
  
  
}

function create(){
  self=this;
  console.log(this);
  map = game.add.tilemap('map');
  map.addTilesetImage('spritesheet');
  layer2= map.createLayer('Tile Layer 2');
  layer= map.createLayer('Tile Layer 1');
  
  
  //layer.debug = true;
  
  // layer.debug = true
  // map.setCollision([7,10]);
  layer.resizeWorld();
  start=map.searchTileIndex(8,0, false,layer2);
  finish=map.searchTileIndex(5,0, false,layer2);
  console.log('start');
  console.log(start);
  console.log('finish');
  console.log(finish);
  // player=game.add.sprite(start.worldX,start.worldY,'dude');
  // player.anchor.set(0.5);
  // p=game.add.sprite(start.worldX,start.worldY,'');
  // game.physics.arcade.enable(player);
  // game.camera.follow(player);
  // player.body.setSize(1,player.height/2,0,20)
  
  //  map.setTileIndexCallback(2, tileProperties, this);
  towers=game.add.group();
  bullets=game.add.group();
  enemies=game.add.group();
  // circle = new Phaser.Circle(game.input.activePointer.x, game.input.activePointer.y,64);
  //  circle.alpha=0.5;
  //  player.circle=circle;
  // circles.add(player);
  
  map.setTileIndexCallback([2,3,4,9], tileProperties, this);
  var cursors = game.input.keyboard.createCursorKeys();
  console.log(map.tilesets[0].tileProperties);
  console.log(map);
  game.input.onDown.add(createCircle,this);
  game.time.events.loop(2000, addEnemy, this);
  //    for(var i=0;i<9;i++){
  //    firstTile=map.searchTileIndex(2, i, false, layer2)
  //    console.log(firstTile);
  //    //console.log(firstTile.worldY);
  // }
}

function update(){
  
  checkRadius();
  
  
  //	whereToGo();
  game.physics.arcade.collide(enemies, layer);
  game.physics.arcade.overlap(enemies, bullets,damaged);
  // player.body.velocity.x = 0;
  // player.body.velocity.y=0;
  
  
  /*  if (cursors.left.isDown)
    {
        //  Move to the left
        player.body.velocity.x = -150;

        player.animations.play('left');
    }
    else if (cursors.right.isDown)
    {
        //  Move to the right
        player.body.velocity.x = 150;

        player.animations.play('right');
    }
    else if (cursors.down.isDown)
    {
        //  Move to the right
        player.body.velocity.y = 150;

        player.animations.play('right');
    }
    else if (cursors.up.isDown)
    {
        //  Move to the right
        player.body.velocity.y = -150;

        player.animations.play('right');
    }
    else
    {
        //  Stand still
        player.animations.stop();

        player.frame = 4;
    }*/
  
  
}
function damaged(enemy,bullet){
 // console.log('damaged');
  // enemy.damage(1);
  // bullet.damage(1);
  if(bullet.exploding)return;
  //console.log('not exploding');
 enemy.damage(1);
  bullet.kill();
}
function checkRadius(){
  
  towers.forEachAlive(function(tower){
    
    enemies.forEachAlive(function(enemy){
      //console.log(enemy);
      if (Phaser.Math.distance(enemy.x, enemy.y, tower.circle.x, tower.circle.y) <= 64) {
        shoot(tower,enemy);
      }
      
    });
    
  });
   
  
}

function explodeRadius(bullet){
    enemies.forEachAlive(function(enemy){
      if (Phaser.Math.distance(enemy.x, enemy.y, bullet.circle.x, bullet.circle.y) <= 30) {
        
        enemy.damage(1);
        
      }
      
      
    });
    bullet.kill();
  }
function render(){
  
  bullets.forEachAlive(renderGeom,this);
  enemies.forEachAlive(renderBody,this);
  towers.forEachAlive(renderGeom,this);
  //this.game.debug.body(this.player.sprite);
  
}
function renderGeom(obj){
  game.debug.geom(obj.circle,'#cfffff',false);
  //this.game.debug.body(obj);
}
function renderBody(obj){
  game.debug.body(obj);
  //this.game.debug.body(obj);
}

function tileProperties(enemy,tile){
  //console.log('reached');
  var destination=map.tilesets[0].tileProperties[tile.index-1];
  //console.log(destination);
  enemy.body.velocity.x=0;
  enemy.body.velocity.y=0;
  if(finish.worldX==tile.worldX && finish.worldY==tile.worldY){
    enemy.kill();
    life--;
    //console.log('life: '+life);
  }else{
    switch(destination.goto){
      case 'left':
        enemy.body.offset.x=10;
        enemy.body.offset.y=0;
        enemy.body.velocity.x=-150;
        break;
        
      case 'right':
        //console.log('go right');
        enemy.body.offset.x=-10;
        enemy.body.offset.y=0;
        enemy.body.velocity.x=150;
        break;
        
      case 'up':
        //console.log('go up');
        enemy.body.offset.y=32;
        enemy.body.offset.x=0;
        enemy.body.velocity.y=-150;
        break;
        
      case 'down':
        //console.log('go down');
        enemy.body.offset.y=-10;
        enemy.body.offset.x=0;
        enemy.body.velocity.y=150;
        break;
        
        
        
    }
  }
  //if(tile.worldX==goingTo[0]&& tile.worldY==goingTo[1]){
  //console.log('reached');
  //console.log(tile);
  //console.log(map.tilesets[0].tileProperties[tile.index-1]);
  
  //player.body.velocity.x = 0;
  //player.body.velocity.y=0;
  //reachedDestination=true;
  //goingTo[0]=0;
  //goingTo[1]=1;
  
}
function goToNext(){
  
}
function shoot(tower,enemy){
  
  if (tower.lastTimeFired < game.time.now - 250) {
    var currentPoint;
    var bullet=game.add.sprite(tower.x,tower.y,'bullet');
   
   
      game.physics.arcade.enable(bullet);
    if(tower.exploding){
    	var radius=new Phaser.Circle(bullet.x, bullet.y,80);
    	 bullet.circle=radius;
    	 
    	 var tween=game.add.tween(bullet.circle).to( {x:enemy.x}, 100, Phaser.Easing.Linear.None,true);
   		 game.add.tween(bullet.circle).to( {y:enemy.y}, 100, Phaser.Easing.Linear.None,true);
   		  game.add.tween(bullet).to( {x:enemy.x}, 100, Phaser.Easing.Linear.None,true);
	    game.add.tween(bullet).to( {y:enemy.y}, 100, Phaser.Easing.Linear.None,true)
	    .onComplete.add(function(){  	  explodeRadius(bullet); 	 });
   
  
    //game.physics.arcade.moveToObject(bullet,enemy,300);
    

    }else{
    	game.physics.arcade.moveToObject(bullet,enemy,300);
    }
   
   
    
    
    
    bullet.body.outOfBoundsKill=true;
    bullet.body.checkWorldBounds=true;
    bullet.lifespan=500; 
    
    tower.lastTimeFired=game.time.now;
    bullets.add(bullet);
    
  }

  
  
  
  //for(var i=1;i<=enemy.mountPoints.ammount;i++){
  //currentPoint=enemy.mountPoints['point'+i];  
  //if(this.state.enemy_bullets.getFirstDead()){
  
  //bullet=this.state.enemy_bullets.getFirstDead();
  //bullet.resetProperties(enemy.x+(currentPoint.x),enemy.y+currentPoint.y+59,enemy.weapon,'enemy');
  //}else{
  //bullet=new Bullet(game,enemy.x+currentPoint.x,enemy.y+currentPoint.y+59,enemy.weapon,'enemy')
  //}
  //}
  
  
  
  
  //var bullet=new Bullet(game,enemy.x,enemy.y+59,enemy.weapon,'enemy')
  //enemy.lastTimeFired=game.time.now;
  
  // }
  
  
}
function addEnemy(){
 
  for(var i=0;i<10;i++){
    game.time.events.add(1000+(100*i), function(){
      
      var enemy=game.add.sprite(start.worldX,start.worldY,'dude');
      enemy.anchor.set(0.5);
      game.physics.arcade.enable(enemy);
      enemy.body.setSize(1,enemy.height/2,0,20);
      enemy.health=1;
      enemy.body.allowGravity=false;
      enemies.add(enemy);
      
    }, this);
    
  }
  
  
}
function createCircle(){
  var selectedTile=map.getTileWorldXY(game.input.activePointer.x, game.input.activePointer.y);
  //console.log(selectedTile);
  if(selectedTile.index==1 && !selectedTile.hasTower){
  	if (choiceMenu!=null){
  		choiceMenu.kill();
  		 choiceMenu=null;
  	}
  	 choiceMenu=game.add.sprite(selectedTile.worldX, selectedTile.worldY-20,'menu');
  	choiceMenu.anchor.x=0.5;

  	var choiceOne=game.add.sprite(-40,0,'tower1');
  	choiceOne.tileX=selectedTile.worldX+16;
  	choiceOne.tileY=selectedTile.worldY+16;
  	choiceMenu.addChild(choiceOne);
  	choiceOne.inputEnabled=true;
	choiceOne.events.onInputDown.add(toCreateTower,this);
	
  	
  	var choiceTwo=game.add.sprite(10,0,'tower2');
	choiceTwo.tileX=selectedTile.worldX+16;
	choiceTwo.tileY=selectedTile.worldY+16;
	choiceMenu.addChild(choiceTwo);
	choiceTwo.inputEnabled=true;
	choiceTwo.events.onInputDown.add(toCreateTower,this);
	

  	function toCreateTower(sprite){
  	
  		createTower(sprite);
  			console.log(sprite);
  		console.log(choiceTwo);
  		console.log(choiceTwo);
  		choiceMenu.kill();
  	}
    // var tower=game.add.sprite(selectedTile.worldX+16, selectedTile.worldY+16,'tower');
    // tower.anchor.set(0.5);
    // circle = new Phaser.Circle(tower.x, tower.y,64);
    // tower.circle=circle;
    // tower.lastTimeFired=0;
    // towers.add(tower);
    // selectedTile.hasTower=true;
  }
}

function createTower(type){
	console.log(type.key);
 var tower=game.add.sprite(type.tileX, type.tileY,type.key);
 tower.anchor.set(0.5);
 if(type.key=='tower2'){
 	tower.exploding=true; 	
 }
  
  circle = new Phaser.Circle(tower.x, tower.y,64);
 	tower.circle=circle;
  tower.lastTimeFired=0;
  towers.add(tower);
  var selectedTile=map.getTileWorldXY(type.tileX, type.tileY);
  	selectedTile.hasTower=true;
 
  //type.kill();
 //selectedTile.hasTower=true;


}
//function whereToGo(){
//if(goingTo.length==0){

//firstTile=map.searchTileIndex(1,0, false)
//goingTo[0]=firstTile.worldX;
//goingTo[1]=firstTile.worldY;

//game.physics.arcade.moveToXY(player,goingTo[0],goingTo[1],80);
//q++;
//console.log('where to go');
//console.log( firstTile);

//}else if(reachedDestination){

//firstTile=map.searchTileIndex(1,q, false, layer2)
//goingTo[0]=firstTile.worldX;
//goingTo[1]=firstTile.worldY;

//game.physics.arcade.moveToXY(player,goingTo[0],goingTo[1],80);
//console.log(q);
//q++;
//reachedDestination=false;

//}

//}
</script>

</body>
</html>